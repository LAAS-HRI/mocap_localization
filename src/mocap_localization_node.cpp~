#include <ros/ros.h>
#include <string>
#include <cstdlib>
#include <cmath>
#include <nlopt.hpp>
#include "../include/optitrack/or_pose_estimator_state.h"
#include <tf/tf.h>
#include <std_msgs/Time.h>
#include <tf/transform_broadcaster.h>
#include <tf/transform_listener.h>
#include <geometry_msgs/PoseWithCovarianceStamped.h>
#include <geometry_msgs/PoseWithCovariance.h>
#include <geometry_msgs/Pose.h>
#include <geometry_msgs/Point.h>
#include <tf/message_filter.h>
#include <message_filters/subscriber.h>
#include <std_srvs/Empty.h>
#include <naoqi_bridge_msgs/JointAnglesWithSpeed.h>

using namespace std;


typedef std::vector < geometry_msgs::Point > PointList_t;

/**************************************************
* Here is the function to minimize by nlopt
***************************************************/
double minfunc(const std::vector<double> &x, std::vector<double> &grad, void *data)
{
    //ROS_INFO("[mocap_localization] Computing f_min");
    PointList_t * data_list = static_cast<PointList_t*>(data);
    // we estimate the radius of the sphere by the mean of the distances from the center of the sphere
    // to reduce by 1 the number of the Svariables
    
    double radius=0.0;
    double sumDistance=0.0;
    double f=0.0;
    int n=data_list->size();
    //ROS_INFO("[mocap_localization] data size =%d test:%f", n,data_list->at(0).x );
    for (unsigned int i = 0; i < data_list->size(); i++)
    {
        sumDistance += pow(data_list->at(i).x-x[0],2) + pow(data_list->at(i).y-x[1],2) + pow(data_list->at(i).z-x[2],2) ;
    }
    radius = sqrt(1.0/data_list->size() * sumDistance);
    //Then we compute f(x) that we want to minimize
    for (unsigned int i = 0; i<data_list->size(); i++)
    {
        f += pow( radius - sqrt( pow(data_list->at(i).x-x[0],2) + pow(data_list->at(i).y-x[1],2) + pow(data_list->at(i).z-x[2],2) ) ,2) ;
    }
    /*
    //Then we compute the gradient of the function
    if (!grad.empty()) {
        grad[0]=0;
        grad[1]=0;
        grad[2]=0;
        for (unsigned int i = 0; i<data_list->size(); i++)
        {
            grad[0] += ( data_list->at(i).x-x[0] / sqrt( pow(data_list->at(i).x-x[0],2) + pow(data_list->at(i).y-x[1],2) + pow(data_list->at(i).z-x[2],2) ) ) + 2*radius ;
            grad[1] += ( data_list->at(i).y-x[1] / sqrt( pow(data_list->at(i).x-x[0],2) + pow(data_list->at(i).y-x[1],2) + pow(data_list->at(i).z-x[2],2) ) ) + 2*radius ;
            grad[2] += ( data_list->at(i).z-x[2] / sqrt( pow(data_list->at(i).x-x[0],2) + pow(data_list->at(i).y-x[1],2) + pow(data_list->at(i).z-x[2],2) ) ) + 2*radius ;
        }
        grad[0] *= 2*radius;
        grad[1] *= 2*radius;
        grad[2] *= 2*radius;
    }*/
    //ROS_INFO("[mocap_localization] f_min =%f", f);
    return f;
}
/*************************************************

**************************************************/

class MocapLocalization
{
private:
    ros::NodeHandle node_;
    tf::TransformListener tfListener_;
    tf::TransformBroadcaster tfBroadcaster_;
    ros::Publisher pose_pub_;
    ros::Publisher joint_pub_;
    ros::Subscriber mocap_sub_;
    ros::Subscriber offset_sub_;
    geometry_msgs::Pose currentPose_;
    tf::MessageFilter<geometry_msgs::PoseStamped> *tfFilter_;
    tf::Transform offsetTf_;
    ros::Subscriber pose_sub_;
    ros::ServiceServer calib_service;
    ros::Timer calib_timer_;
    bool calibMode_;
    int calibCpt_;
    PointList_t calibPoint_list_;
public:
    MocapLocalization(ros::NodeHandle node) : currentPose_(), 
                                              tfListener_(), 
                                              tfBroadcaster_(),
                                              offsetTf_(),
                                              calibMode_(false), 
                                              calibCpt_(0), 
                                              calibPoint_list_()
    {
        node_=node;
        //Subscribers
        mocap_sub_ = node_.subscribe("/optitrack/bodies/mummer", 10, &MocapLocalization::mocapCallback,this);
        offset_sub_ = node_.subscribe("/initialpose", 1, &MocapLocalization::initPoseReceived,this);
        //Publishers
        pose_pub_ = node_.advertise<geometry_msgs::PoseStamped>("/mocap_localization/mummer_base_pose_raw", 10);
        joint_pub_ = node_.advertise<naoqi_bridge_msgs::JointAnglesWithSpeed>("/pepper_robot/pose/joint_angles", 10);
        pose_sub_ = node_.subscribe("/mocap_localization/mummer_base_pose_raw", 10, &MocapLocalization::update,this);
        //Service servers
        calib_service = node_.advertiseService("/mocap_localization/calibration", &MocapLocalization::calibInit, this);
        //Timers
        calib_timer_ = node_.createTimer(ros::Duration(1.0), &MocapLocalization::calibCallback,this);
        ROS_INFO("[mocap_localization] Motion capture localization ready");
        offsetTf_.setIdentity();
    };
private:
    void update(const geometry_msgs::PoseStamped::ConstPtr pose_ptr)
    {
        try
        {   
            tf::Transform tfMap2Base;
            tf::StampedTransform tfOdom2Base;

            tf::Pose tfPose;
            tf::poseMsgToTF(pose_ptr->pose, tfPose);
            tfPose=offsetTf_*tfPose;

            tfListener_.waitForTransform("/odom", "/base_link", ros::Time(0), ros::Duration(3.0));
            tfListener_.lookupTransform("/odom", "/base_link", ros::Time(0), tfOdom2Base);

            tfMap2Base.setOrigin(tfPose.getOrigin());
            tfMap2Base.setRotation(tfPose.getRotation());
            
            tfBroadcaster_.sendTransform(tf::StampedTransform((tfMap2Base*tfOdom2Base.inverse()), tfOdom2Base.stamp_, "map", "odom"));
        }
        catch (tf::TransformException &ex) 
        {
          ROS_ERROR("[mocap_localization] Error occur : %s\n", ex.what());
        }
    };

    void mocapCallback(const optitrack::or_pose_estimator_state::ConstPtr &msg)
    {
        if(!msg->pos.empty())
        {
            //If we receive data from mocap system we update the current pose
            //Setting position
            currentPose_.position.x=msg->pos[0].x;
            currentPose_.position.y=msg->pos[0].y;
            currentPose_.position.z=msg->pos[0].z;
            //Setting orientation
            currentPose_.orientation.x=msg->pos[0].qx;
            currentPose_.orientation.y=msg->pos[0].qy;
            currentPose_.orientation.z=msg->pos[0].qz;
            currentPose_.orientation.w=msg->pos[0].qw;
        }
        //Stamping the pose with covariance that will be used to filter tf
        geometry_msgs::PoseStamped temp_pose;
        temp_pose.pose=currentPose_;
        temp_pose.header.frame_id="/map";
        temp_pose.header.stamp.sec=msg->ts.sec;
        temp_pose.header.stamp.nsec=msg->ts.nsec;
        //Publishing the pose to be used by update(..)
        pose_pub_.publish(temp_pose);
    };
    void initPoseReceived(const geometry_msgs::PoseWithCovarianceStampedConstPtr& msg)
    {
        tf::Pose pose;
        tf::poseMsgToTF(msg->pose.pose, pose);
        tf::StampedTransform tfBase2Map;
        tf::StampedTransform tfBase2Odom;
        try{
            // just get the latest
            tfListener_.lookupTransform("/base_footprint", "/map", ros::Time(0), tfBase2Map);
        } catch(tf::TransformException){
            ROS_WARN("Failed to lookup transform!");
            return;
        }
        tf::Transform delta;
        delta = pose * tfBase2Map;
        offsetTf_ = delta * offsetTf_;
    };
    bool calibInit(std_srvs::Empty::Request& req, std_srvs::Empty::Response& res)
    {
        calibCpt_=0;
        calibPoint_list_.clear();
        calibMode_=true;
        ROS_INFO("[mocap_localization] Starting calibration");
        return(true);
    };
    void calibCallback(const ros::TimerEvent&)
    {
        if(calibMode_)
        {
            naoqi_bridge_msgs::JointAnglesWithSpeed jointCommand;
            if(calibCpt_<20)
            {
                if(calibCpt_%2==0)
                {
                    //TODO send command
                    jointCommand.joint_names.push_back("HipPitch");
                    jointCommand.joint_names.push_back("KneePitch");
                    double angle=-(1.0385*2/3)+(((1.0385*2/3))/10.0)*(calibCpt_/2);
                    ROS_INFO("[mocap_localization] Sending command %d/9 angle:%f",calibCpt_/2,angle);
                    if (angle>-1.0385 && angle <1.0385)
                    {
                        jointCommand.joint_angles.push_back(angle);
                        jointCommand.joint_angles.push_back(0.0);
                        jointCommand.speed=0.05;
                        jointCommand.relative=0;
                        joint_pub_.publish(jointCommand);
                    } else {
                        ROS_WARN("[mocap_localization] Angle out of bound, command not send");
                    }
                } else {
                    tf::Pose poseTf;
                    geometry_msgs::Pose poseMsg;
                    tf::poseMsgToTF(currentPose_, poseTf);
                    tf::poseTFToMsg(offsetTf_*poseTf, poseMsg);
                    ROS_INFO("[mocap_localization] Getting experimental point x:%f y:%f z:%f",poseMsg.position.x,poseMsg.position.y,poseMsg.position.z);
                    calibPoint_list_.push_back(poseMsg.position);
                }
                calibCpt_++;
            } else
            {
                //TODO calculate spherical regression
                ROS_INFO("[mocap_localization] Setting calibration...");
                nlopt::opt opt(nlopt::LN_COBYLA, 3);
                std::vector<double> lb(3);
                lb[0] = 1e-4; lb[1] = 1e-4; lb[2] = 1e-4;
                opt.set_lower_bounds(lb);
                opt.set_min_objective(minfunc, &calibPoint_list_);
                std::vector<double> x(3);
                x[0] = 1.0; x[1] = 1.0; x[2] = 1.0;
                opt.set_xtol_rel(1e-4);
                double minf;
                ROS_INFO("[mocap_localization] Optimizing...");
                nlopt::result result = opt.optimize(x, minf);
                calibMode_=false;
                ROS_INFO("[mocap_localization] Calibration end");
                ROS_INFO("[mocap_localization] Center of the sphere from optimization x:%f , y:%f , z:%f", x[0], x[1], x[2] );
                
                double sumDistance=0.0;
                for (unsigned int i = 0; i < calibPoint_list_.size(); i++)
                {
                    sumDistance += pow(calibPoint_list_.at(i).x-x[0],2) + pow(calibPoint_list_.at(i).y-x[1],2) + pow(calibPoint_list_.at(i).z-x[2],2) ;
                }
                float radius = sqrt(1.0/calibPoint_list_.size() * sumDistance);

                ROS_INFO("[mocap_localization] Radius estimation of the sphere r:%f",radius);
                
            }
        }
    };
};

int main(int argc, char** argv){
  ros::init(argc, argv, "mocap_localization");
  ros::NodeHandle node;
  MocapLocalization mcl(node);
  ros::spin();
  return 0;
};
